import express from "express"
import compression from 'compression'
import { Telegraf } from "telegraf"
import bodyParser from 'body-parser'
import cors from 'cors'
import * as dotenv from 'dotenv'
import { GoogleSpreadsheet } from 'google-spreadsheet'
import { JWT } from 'google-auth-library'
import axios from 'axios'
// import { SocksProxyAgent } from 'socks-proxy-agent'
import serveStatic from 'serve-static'
import { open } from 'sqlite'
import sqlite3 from 'sqlite3'
import ibantools from 'ibantools'
import { EventEmitter } from 'events'
import twilio from 'twilio'
import * as bolt11 from "bolt11"

import * as ridivi from "./ridivi.js"

dotenv.config()

const telegram_bot_token = process.env.telegram_bot_token
const port = process.env.port
const chat_id = process.env.chat_id
const base_path = process.env.base_path
const api_key = process.env.api_key
const google_sheet_id = process.env.google_sheet_id
const service_account_json = (process.env.service_account_json_base64 ? JSON.parse(Buffer.from(process.env.service_account_json_base64, 'base64').toString()) : null)
const service_account_email = process.env.service_account_email
const exchange_rate_api_key = process.env.exchange_rate_api_key
const invoice_endpoint_url = process.env.invoice_endpoint_url
const invoice_endpoint_user = process.env.invoice_endpoint_user
const invoice_endpoint_password = process.env.invoice_endpoint_password
const price_data_url = process.env.price_data_url
const lnurl_base_url = process.env.lnurl_base_url
const db_location = process.env.db_location
const admin_api_key = process.env.admin_api_key
const sparkwallet_url = process.env.sparkwallet_url
const sparkwallet_user = process.env.sparkwallet_user
const sparkwallet_password = process.env.sparkwallet_password
const ridivi_id = process.env.ridivi_id
const ridivi_crc_account = process.env.ridivi_crc_account
const ridivi_usd_account = process.env.ridivi_usd_account
const ridivi_name = process.env.ridivi_name
const twilio_account_sid = process.env.twilio_account_sid
const twilio_auth_token = process.env.twilio_auth_token
const twilio_from_number = process.env.twilio_from_number
const default_daily_sell_limit = process.env.default_daily_sell_limit
const default_daily_buy_limit = process.env.default_daily_buy_limit
const default_per_txn_limit = process.env.default_per_txn_limit

const twilioClient = twilio(twilio_account_sid, twilio_auth_token)

const corsOptions = {
  origin: process.env.NODE_ENV !== "production" ? 'http://localhost:3001' : 'https://orders.bitcoinjungle.app',
}

// connect to the db
const db = await open({
  filename: db_location,
  driver: sqlite3.Database
})

const serviceAccountAuth = new JWT({
  // env var values here are copied from service account credentials generated by google
  // see "Authentication" section in docs for more info
  email: service_account_email,
  key: service_account_json.private_key,
  scopes: [
    'https://www.googleapis.com/auth/spreadsheets',
  ],
})

const doc = new GoogleSpreadsheet(google_sheet_id, serviceAccountAuth)

await doc.loadInfo()

console.log('loaded doc', doc.title)

const bot = new Telegraf(telegram_bot_token)
const app = express()

const googleSheetEventHandler = new EventEmitter()
const telegramEventHandler = new EventEmitter()
const processOrderEventHandler = new EventEmitter()
const twilioEventHandler = new EventEmitter()

let BTCCRC, USDCRC, USDCAD, BTCUSD, BTCCAD

googleSheetEventHandler.on('addRow', async ({rowData, sheet: sheetIndex}) => {
  console.log('adding row to sheet ' + sheetIndex)

  const added = await addRowToSheet(rowData, sheetIndex)

  if(!added) {
    await new Promise(resolve => setTimeout(resolve, 1000 * 10))
    return await addRowToSheet(rowData, sheetIndex)
  }

  return true
})

telegramEventHandler.on('sendMessage', async ({rowData, formulaFreeAmount, timestamp, error}) => {
  console.log('sending tg message')
  
  const telegramMessage = await sendOrderToTelegram(rowData, formulaFreeAmount, timestamp, error)

  if(!telegramMessage) {
    await new Promise(resolve => setTimeout(resolve, 1000 * 10))
    await sendOrderToTelegram(rowData, formulaFreeAmount, timestamp, error)
  }

  return true
})

processOrderEventHandler.on('processOrder', async ({rowData, formulaFreeAmount, timestamp, tryNum}) => {
  console.log('processing order')

  try {
    let urlToCall = (process.env.NODE_ENV !== "production" ? 'http://localhost:3000' : 'https://orders.bitcoinjungle.app')
    if(rowData.Type === 'Buy') {
      urlToCall += '/payInvoice/?'
    } else {
      urlToCall += '/payFiat/?'
    }

    urlToCall += new URLSearchParams({timestamp: timestamp, apiKey: admin_api_key}).toString()

    console.log('calling', urlToCall)

    const response = await axios(urlToCall)

    console.log('call complete', response.data)

    if(response.data.error) {
      console.log('error calling')

      if(!tryNum || tryNum < 4) {
        tryNum = (!tryNum ? 2 : tryNum + 1)
        await new Promise(resolve => setTimeout(resolve, 1000 * 60 * tryNum))
        console.log(`trying again ${tryNum}...`)

        processOrderEventHandler.emit(
          'processOrder',
          {
            rowData,
            formulaFreeAmount,
            timestamp,
            tryNum: tryNum
          }
        )

        return false
      }

      telegramEventHandler.emit(
        'sendMessage',
        {
          rowData,
          formulaFreeAmount,
          timestamp,
          error: response.data.message,
        }
      )

      return false
    }

    return true
  } catch(e) {
    console.log('error processing order', e)
    return false
  }
})

twilioEventHandler.on('message', async ({ type, data, name, phoneNumber, amount, currency }) => {
  let referenceNumber = ''

  if(!data.data) {
    return false
  }

  if(type === "sendLoadTransferCh4") {
    if(!data.data.result) {
      return false
    }

    if(!data.data.result.ReferenciaSinpe) {
      return false
    }

    referenceNumber = data.data.result.ReferenciaSinpe
  } else if(type === "sendLoadedTransfer") {
    if(!data.data.send) {
      return false
    }

    if(!data.data.send.length) {
      return false
    }

    if(!data.data.send[1]) {
      return false
    }

    if(!data.data.send[1].referenceNumber) {
      return false
    }

    referenceNumber = data.data.send[1].referenceNumber
  }

  if(!referenceNumber) {
    return false
  }

  try {
    const resp = await twilioClient.messages.create({
      body: `Toro Pagos: Usted ha enviado ${amount} ${currency} a ${name}. Comprobante ${referenceNumber}`,
      from: twilio_from_number,
      to: phoneNumber
    })

    return true
  } catch (e) {
    console.log('twilio error', e)
    return false
  }
})

app.use(bodyParser.json())
app.use(compression())
app.use(cors(corsOptions))
app.use(async (req, res, next) => {
  if(req.path === '/' && !req.query.registered) {
    const isBj = !!res.req.headers['x-bj-wallet'] || !!req.query.fromBJ
    const username = res.req.query.username

    if(isBj && username) {
      const userRegistered = await getUser(db, username)

      if(!userRegistered || !userRegistered.approved) {
        return res.redirect('/?' + new URLSearchParams({...req.query, registered: false}).toString())
      } else {
        return res.redirect('/?' + new URLSearchParams({...req.query, registered: true}).toString())
      }
    }
  }

  if(req.path === '/admin' || req.path === '/admin/' || req.path === '/admin/index.html') {
    const key = req.query.key

    if(key !== admin_api_key) {
      return res.sendStatus(401)
    }
  }

  next()
})
app.use(serveStatic('front_end/build', { 'index': ['index.html'] }))
app.use("/admin", serveStatic('admin_front_end/build', { 'index': ['index.html'] }))
app.use("/chart", serveStatic('chart_front_end/build', { 'index': ['index.html'] }))

app.post('/order', async (req, res) => {
  const apiKey = req.body.apiKey
  const fiatAmount = (req.body.fiatAmount ? parseFloat(req.body.fiatAmount.replace(/,/g, "")) : null)
  const fiatCurrency = (req.body.fiatCurrency ? req.body.fiatCurrency.toUpperCase() : null)
  const satAmount  = (req.body.satAmount ? parseInt(req.body.satAmount.replace(/,/g, "").replace(/\./g, "")) : null)
  const action  = (req.body.action ? req.body.action.toUpperCase() : null)
  let paymentReq = (req.body.paymentReq ? req.body.paymentReq : null)
  const paymentDesc = (req.body.paymentDesc ? req.body.paymentDesc.trim().replaceAll(/bitcoin|btc|sats|cripto|crypto|bit /gi, '').substr(0,15) : null)
  const phoneNumber = (req.body.phoneNumber ? req.body.phoneNumber.replace(/[^\d]+/g, "").trim() : null)
  const timestamp = (req.body.timestamp ? req.body.timestamp : new Date().toISOString())
  const invoice = (req.body.invoice ? req.body.invoice : null)
  const paymentHash = (req.body.paymentHash ? req.body.paymentHash : null)
  const paymentIdentifier = (req.body.paymentIdentifier && req.body.action === "BUY" ? req.body.paymentIdentifier : "")
  const username = (req.body.username ? req.body.username : null)
  
  const billerCategory = req.body.billerCategory
  const billerService = req.body.billerService
  const billerActionType = req.body.billerActionType
  const billerAccountNumber = req.body.billerAccountNumber

  if(action === 'BILLPAY') {
    paymentReq = 'Bill Payment'
  }

  const orderInFlight = await getOrder(db, timestamp)

  if(orderInFlight) {
    if(orderInFlight.status === 'complete') {
      return res.send({success: true})
    }

    if(orderInFlight.status === 'in-flight') {
      return res.send({inFlight: true})
    }
  }

  console.log('order received', req.body)

  if(!apiKey) {
    return res.send({error: true, type: "apiKeyRequired"})
  }

  if(apiKey !== api_key) {
    return res.send({error: true, type: "apiKeyIncorrect"})
  }

  if(!fiatAmount) {
    return res.send({error: true, type: "fiatAmountRequired"})
  }

  if(!fiatCurrency) {
    return res.send({error: true, type:"fiatCurrencyRequired"})
  }

  if(fiatCurrency !== 'USD' && fiatCurrency !== 'CRC') {
    return res.send({error: true, type: "invalidFiatCurrency"})
  }

  if(!satAmount) {
    return res.send({error: true, type: "satAmountRequired"})
  }

  if(!action) {
    return res.send({error: true, type: "actionRequired"})
  }

  if(!paymentReq) {
    return res.send({error: true, type: "paymentReqRequired"})
  }

  if(!phoneNumber) {
    return res.send({error: true, type: "phoneNumberRequired"})
  }

  if(action !== 'BUY' && action !== 'SELL' && action !== 'BILLPAY') {
    return res.send({error: true, type: "invalidAction"})
  }

  if(action === 'BUY' && paymentReq.toLowerCase().indexOf('lnbc') !== 0) {
    return res.send({error: true, type: "invalidPaymentReqBuy"})
  }

  if(action === 'BUY' && !paymentIdentifier) {
    return res.send({error: true, type: "paymentIdentifierRequired"})
  }

  if(action === 'BUY') {
    const paymentIdentifierExists = await getPaymentIdentifier(db, paymentIdentifier)

    if(paymentIdentifierExists) {
      return res.send({error: true, type: "paymentIdentifierUsed"})
    }
  }

  if(action === 'BILLPAY' && (!billerCategory || !billerService || !billerActionType || !billerAccountNumber)) {
    return res.send({error: true, type: "invalidBillPaySettings"})
  }

  if((action === 'SELL' || action === 'BILLPAY') && (!invoice || !paymentHash || !timestamp)) {
    return res.send({error: true, type: "invalidInvoice"})
  }

  if(action === 'SELL') {
    const isValidIban = ibantools.isValidIBAN(ibantools.electronicFormatIBAN(paymentReq))
    const isValidSinpe = paymentReq.replace(/[^0-9]/gi, '').trim().length === 8

    if(!isValidIban && fiatCurrency === 'USD') {
      return res.send({error: true, type: "usdIbanRequired"})
    }

    if(!isValidIban && !isValidSinpe) {
      return res.send({error: true, type: "invalidPaymentReqSell"})
    }

    // if(isValidSinpe) {
    //   const phoneNumberCheck = await checkPhoneNumberForSinpe(paymentReq.replace(/[^0-9]/gi, '').trim())

    //   if(phoneNumberCheck.error) {
    //     return res.send({error: true, message: phoneNumberCheck.message})
    //   }
    // }
  }

  const isOver = await isUserOverDailyLimit({action, phoneNumber, fiatAmount, fiatCurrency})

  if(isOver) {
    return res.send({error: true, type: "isOverDailyLimit", data: isOver})
  }

  const orderAdded = await addOrder(db, timestamp)

  if(!orderAdded) {
    return res.send({error: true, type: "duplicateOrder"})
  }

  if(action === 'SELL' || action === 'BILLPAY') {
    let invoicePaid
    for (var i = 0; i < 100; i++) {
      console.log('checking invoice', i, timestamp)

      invoicePaid = await checkInvoice(timestamp)

      if(invoicePaid) {
        const decodedInvoice = bolt11.decode(invoicePaid.bolt11)

        if(!decodedInvoice) {
          console.log('cant decode invoice, failing')
          return res.send({error: true, type: "invoiceNotPaid"})
        }

        if(decodedInvoice.satoshis > satAmount * 1.05) {
          console.log("invoice sat amount is more than 5% over order sat amount. Please review manually.")
          return res.send({error: true, type: "invoiceNotPaid"})
        }

        if(decodedInvoice.satoshis < satAmount * 0.95) {
          console.log("invoice sat amount is more than 5% under order sat amount. Please review manually.")
          return res.send({error: true, type: "invoiceNotPaid"})
        }

        console.log('invoice paid', timestamp)
        break
      } else {
        await new Promise(resolve => setTimeout(resolve, 2500))
      }
    }

    if(!invoicePaid) {
      await deleteOrder(db, timestamp)
      return res.send({error: true, type: "invoiceNotPaid"})
    }
  }

  const satAmountFormatted = Number(satAmount).toLocaleString()
  const fiatAmountFormatted = Number(fiatAmount).toLocaleString()

  let fromCurrency = null
  let fromAmount = null
  let toCurrency = null
  let toAmount = null
  let paymentType = null
  let paymentDestination = null
  let type = null
  let formulaFreeAmount = (satAmount / 100000000).toFixed(8)

  switch(action) {
    case 'BUY':
      fromCurrency = fiatCurrency
      fromAmount = fiatAmountFormatted

      toCurrency = 'BTC'
      toAmount = `=(${satAmount} / 100000000)`

      paymentType = 'SINPE'
      type = 'Buy'

      paymentDestination = paymentReq
      
      break;

    case 'SELL':
    case 'BILLPAY':
      fromCurrency = 'BTC'
      fromAmount = `=(${satAmount} / 100000000)`

      toCurrency = fiatCurrency
      toAmount = fiatAmountFormatted

      type = 'Sell'

      if(action === 'BILLPAY') {
        paymentType = 'Bill Payment'
      } else {
        paymentType = 'SINPE'
      }

      paymentDestination = paymentReq

      break;

    default:
      console.log('no buy nor sell uh-oh')
      break;
  }

  const rowData = { 
    "Date": timestamp,
    "Type": type,
    "From Amount": fromAmount,
    "From Currency": fromCurrency,
    "To Amount": toAmount,
    "To Currency": toCurrency,
    "Payment Type": paymentType,
    "Payment Identifier": paymentIdentifier,
    "Payment Destination": paymentDestination,
    "Biller Category": billerCategory,
    "Biller Service": billerService,
    "Biller Action Type": billerActionType,
    "Biller Account Number": billerAccountNumber,
    "Settlement LN Invoice": invoice,
    "Invoice Payment PreImage": paymentHash,
    "USD/CRC": USDCRC.indexPrice,
    "USD/CAD": USDCAD,
  }

  console.log('processed order data to', rowData)

  await updateOrderData(db, timestamp, rowData)

  try {
    const phoneUser = await getPhoneNumber(db, phoneNumber)

    if(!phoneUser) {
      console.log('adding new phoneUser')

      await addPhoneNumber(db, phoneNumber)
      const newUser = await getPhoneNumber(db, phoneNumber)

      googleSheetEventHandler.emit(
        'addRow', 
        {
          rowData: {
            "Date": timestamp,
            "Customer ID": newUser.id,
            "Phone Number": phoneNumber,
          },
          sheet: 1,
        }
      )

      rowData['User'] = newUser.id
    } else {
      console.log('found existing phoneUser')

      rowData['User'] = phoneUser.id
    }
  } catch(e) {
    console.log('error finding phoneUser', e)
  }

  if(action === "BUY") {
    await addPaymentIdentifier(db, paymentIdentifier)
  }

  await updateOrderData(db, timestamp, {
    ...rowData, 
    "Username": username, 
    "Payment Description": paymentDesc,
  })
  await updateOrderStatus(db, timestamp, 'complete')

  googleSheetEventHandler.emit(
    'addRow', 
    {
      rowData,
      sheet: 0,
    }
  )

  console.log('order submitted successfully.')

  const userToAllow = await getPhoneNumber(db, phoneNumber)

  if(userToAllow && userToAllow.allow_instant == 1) {
    console.log('processing instantly!')

    processOrderEventHandler.emit(
      'processOrder',
      {
        rowData,
        formulaFreeAmount,
        timestamp,
      }
    )
  } else {
    telegramEventHandler.emit(
      'sendMessage',
      {
        rowData,
        formulaFreeAmount,
        timestamp,
        error: 'user allow_instant is false',
      }
    )
  }

  return res.send({success: true})
})

app.post('/invoice', async (req, res) => {
  const apiKey = req.body.apiKey
  const label = req.body.label
  const description = req.body.description
  const satAmount = req.body.satAmount
  const action = req.body.action
  const fiatAmount = (req.body.fiatAmount ? parseFloat(req.body.fiatAmount.replace(/,/g, "")) : null)
  const fiatCurrency = req.body.fiatCurrency
  const phoneNumber = (req.body.phoneNumber ? req.body.phoneNumber.replace(/[^\d]+/g, "").trim() : null)
  const paymentReq = (req.body.paymentReq ? req.body.paymentReq : null)

  if(!apiKey) {
    return res.send({error: true, type: "apiKeyRequired"})
  }

  if(apiKey !== api_key) {
    return res.send({error: true, type: "apiKeyIncorrect"})
  }

  if(!label) {
    return res.send({error: true, message: "Label is required"})
  }

  if(!description) {
    return res.send({error: true, message: "Description is required."})
  }

  if(!satAmount) {
    return res.send({error: true, type: "satAmountRequired"})
  }

  if(!action) {
    return res.send({error: true, type: "actionRequired"})
  }

  if(!fiatAmount) {
    return res.send({error: true, type: "fiatAmountRequired"})
  }

  if(!fiatCurrency) {
    return res.send({error: true, type: "fiatCurrencyRequired"})
  }

  if(!phoneNumber) {
    return res.send({error: true, type: "phoneNumberRequired"})
  }

  const blocked = await getDestinationBlocklist(db, paymentReq)

  if(blocked) {
    return res.send({error: true, type: "paymentDestinationBlocked"})
  }

  const isOver = await isUserOverDailyLimit({action, phoneNumber, fiatAmount, fiatCurrency})

  if(isOver) {
    return res.send({error: true, type: "isOverDailyLimit", data: isOver})
  }

  const invoiceData = {
    jsonrpc: "2.0",
    id: Math.floor(Math.random() * 1001).toString(),
    method: "createInvoice",
    params: {
      label: label,
      description: description,
      msatoshi: parseInt(satAmount * 1000),
    }
  }

  try {
    const response = await axios(invoice_endpoint_url, {
      method: "POST",
      auth: {
        username: invoice_endpoint_user,
        password: invoice_endpoint_password,
      },
      data: invoiceData,
    })

    return res.send(response.data)
  } catch(e) {
    console.log('create invoice error', e)
    return res.send({error: true, message: "An unexpected error has occurred."})
  }
})

app.get('/price', async (req, res) => {
  const priceData = await getPrice()
  return res.send(priceData)
})

app.get('/ticker', async (req, res) => {
  const tickerData = getTicker()
  return res.send(tickerData)
})

app.get('/order', (req, res) => {
  let uri = '/'
  if(req.query.key) {
    uri = '/?key=' + req.query.key
  }
  res.redirect(uri)
})

app.get('/user', async (req, res) => {
  const apiKey = req.body.apiKey
  const bitcoinJungleUsername = req.query.bitcoinJungleUsername

  if(!apiKey) {
    return res.send({error: true, message: "apiKey is required"})
  }

  if(apiKey !== admin_api_key) {
    return res.send({error: true, message: "apiKey is incorrect"})
  }

  if(!bitcoinJungleUsername) {
    return res.send({error: true, message: "username is required"})
  }

  const user = await getUser(db, bitcoinJungleUsername)

  if(!user) {
    return res.send({error: true, message: "username doesn't exist"})
  }

  return res.send({success: true, data: user})
})

app.post('/addUser', async (req, res) => {
  const apiKey = req.body.apiKey
  const bitcoinJungleUsername = req.body.bitcoinJungleUsername
  const phoneNumber = req.body.phoneNumber

  if(!apiKey) {
    return res.send({error: true, message: "apiKey is required"})
  }

  if(apiKey !== api_key) {
    return res.send({error: true, message: "apiKey is incorrect"})
  }

  if(!bitcoinJungleUsername) {
    return res.send({error: true, message: "username is required"})
  }

  if(!phoneNumber) {
    return res.send({error: true, message: "phone number is required"})
  }

  const userExists = await getUser(db, bitcoinJungleUsername)

  if(userExists) {
    if(userExists.approved) {
      return res.send({error: true, type: "approved"})
    }

    if(!userExists.approved) {
      return res.send({error: true, type: "pendingApproval"})
    }
  }

  const user = await addUser(db, bitcoinJungleUsername)

  if(!user) {
    return res.send({error: true, message: "error adding user"})
  }

  let phoneName = ''
  if(phoneNumber.indexOf('506') === 0 || phoneNumber.indexOf('+506') === 0) {
    let numberToSearch = phoneNumber.replaceAll(/[^0-9]/gi, '').replace(/^506/, '').trim()

    if(numberToSearch.length === 8) {
      const phoneNumberCheck = await checkPhoneNumberForSinpe(numberToSearch)

      if(!phoneNumberCheck.error && phoneNumberCheck.data && phoneNumberCheck.data.NombreCliente) {
        phoneName = phoneNumberCheck.data.NombreCliente
      }
    }
  }

  if(!phoneName.length) {
    const tgMsg = await sendUserAddMessage(bitcoinJungleUsername, phoneNumber, phoneName)
    return res.send({success: true})
  } else {
    const approve = await approveUser(db, bitcoinJungleUsername)
    return res.send({error: true, type: "approved"})
  }
})

app.get('/approveUser', async (req, res) => {
  const apiKey = req.body.apiKey || req.query.apiKey
  const bitcoinJungleUsername = req.body.bitcoinJungleUsername || req.query.bitcoinJungleUsername

  if(req.headers['user-agent'].indexOf('TelegramBot') !== -1) {
    return res.send({error: true, message: "no bots"})
  }

  if(!apiKey) {
    return res.send({error: true, message: "apiKey is required"})
  }

  if(apiKey !== admin_api_key) {
    return res.send({error: true, message: "apiKey is incorrect"})
  }

  if(!bitcoinJungleUsername) {
    return res.send({error: true, message: "username is required"})
  }

  const user = await getUser(db, bitcoinJungleUsername)

  if(!user) {
    return res.send({error: true, message: "username does not exist"})
  }

  const update = await approveUser(db, bitcoinJungleUsername)

  if(!update) {
    return res.send({error: true, message: "error approving user"})
  }

  return res.send({success: true})
})

app.post('/deactivateUser', async (req, res) => {
  const apiKey = req.body.apiKey
  const bitcoinJungleUsername = req.body.bitcoinJungleUsername

  if(!apiKey) {
    return res.send({error: true, message: "apiKey is required"})
  }

  if(apiKey !== admin_api_key) {
    return res.send({error: true, message: "apiKey is incorrect"})
  }

  if(!bitcoinJungleUsername) {
    return res.send({error: true, message: "username is required"})
  }

  const user = await getUser(db, bitcoinJungleUsername)

  if(!user) {
    return res.send({error: true, message: "username does not exist"})
  }

  const update = await deactivateUser(db, bitcoinJungleUsername)

  if(!update) {
    return res.send({error: true, message: "error deactivating user"})
  }

  return res.send({success: true})
})

app.post('/addToSheet', async (req, res) => {
  const timestamp = req.body.timestamp

  if(!timestamp) {
    return res.send({error: true, message: "timestamp is required"})
  }

  const order = await getOrder(db, timestamp)

  if(!order) {
    return res.send({error: true, message: "order not found"})
  }

  const data = JSON.parse(order.data)

  const added = await addRowToSheet(data, 0)

  return res.send({success: true})
})

app.get('/checkPhoneNumberForSinpe', async (req, res) => {
  let phoneNumber = req.query.phoneNumber
  const apiKey = req.query.apiKey

  if(!apiKey) {
    return res.send({error: true, type: "apiKeyRequired"})
  }

  if(apiKey !== api_key) {
    return res.send({error: true, type: "apiKeyIncorrect"})
  }

  if(!phoneNumber) {
    return res.send({error: true, message: "phoneNumber is required"})
  }

  phoneNumber = phoneNumber.replace(/[^0-9]/gi, '').trim()

  if(phoneNumber.length !== 8) {
    return res.send({error: true, message: "phoneNumber must be 8 digits"})
  }

  const blocked = await getDestinationBlocklist(db, phoneNumber)

  if(blocked) {
    return res.send({error: true, type: "paymentDestinationBlocked"})
  }

  const result = await checkPhoneNumberForSinpe(phoneNumber)

  return res.send(result)
})

app.get('/checkIbanAccount', async (req, res) => {
  let iban = req.query.iban
  const apiKey = req.query.apiKey

  if(!apiKey) {
    return res.send({error: true, type: "apiKeyRequired"})
  }

  if(apiKey !== api_key) {
    return res.send({error: true, type: "apiKeyIncorrect"})
  }

  if(!iban) {
    return res.send({error: true, message: "iban is required"})
  }

  const isValidIban = ibantools.isValidIBAN(ibantools.electronicFormatIBAN(iban))
 
  if(!isValidIban) {
    return res.send({error: true, message: "iban account is invalid"})
  }

  const blocked = await getDestinationBlocklist(db, iban)

  if(blocked) {
    return res.send({error: true, type: "paymentDestinationBlocked"})
  }

  const result = await checkIbanAccount(ibantools.electronicFormatIBAN(iban))

  return res.send(result)
})

app.post('/editOrder', async (req, res) => {
  const apiKey = req.body.apiKey
  const timestamp = req.body.timestamp
  const data = req.body.data

  if(!apiKey) {
    return res.send({error: true, message: "apiKey is required"})
  }

  if(apiKey !== admin_api_key) {
    return res.send({error: true, message: "apiKey is incorrect"})
  }

  if(!timestamp) {
    return res.send({error: true, message: "timestamp is required"})
  }

  if(!data) {
    return res.send({error: true, message: 'data is required'})
  }

  const order = await getOrder(db, timestamp)

  if(!order) {
    return res.send({error: true, message: "order not found"})
  }

  if(data["Payment Identifier"]) {
    const existing = await getPaymentIdentifier(db, data["Payment Identifier"])

    if(existing && existing.identifier != data["Payment Identifier"]) {
      return res.send({error: true, message: "payment identifier already exists, can't update"})
    }

    const newIdentifier = await addPaymentIdentifier(db, data["Payment Identifier"])

    if(!newIdentifier) {
      return res.send({error: true, message: "error adding new payment identifier"})
    }
  }

  const orderData = JSON.parse(order.data)

  const merged = {...orderData, ...data}

  const updated = await updateOrderData(db, timestamp, merged)

  if(!updated) {
    return res.send({error: true, message: "error updating order"})
  }

  return res.send({success: true})
})

app.get('/refundOrder', async (req, res) => {
  const apiKey = req.query.apiKey
  const timestamp = req.query.timestamp

  if(!apiKey) {
    return res.send({error: true, message: "apiKey is required"})
  }

  if(apiKey !== admin_api_key) {
    return res.send({error: true, message: "apiKey is incorrect"})
  }

  if(!timestamp) {
    return res.send({error: true, message: "timestamp is required"})
  }

  const order = await getOrder(db, timestamp)

  if(!order) {
    return res.send({error: true, message: "order not found"})
  }

  if(order.status !== 'complete') {
    return res.send({error: true, message: "order has not been processed internally yet"})
  }

  if(order.paymentStatus === 'in-flight') {
    return res.send({error: true, message: "order payment status is currently in-flight"})
  }

  if(order.paymentStatus === 'complete') {
    return res.send({error: true, message: "order payment status is already complete, can't pay a lightning invoice twice."})
  }

  let orderData = {}
  try {
    orderData = JSON.parse(order.data)
  } catch (e) {
    console.log('error parsing order data json', e)
    return res.send({error: true, message: "error parsing order data json"})
  }

  if(!orderData.Username || !orderData.Username.length) {
    return res.send({error: true, message: "order doesn't have a username, can't refund. please handle manually"})
  }

  if(orderData.Type !== "Sell") {
    return res.send({error: true, message: "can only send sats for 'Sell' orders"})
  }

  const satAmount = parseFloat(eval(orderData['From Amount'].replace('=', '')))

  if(!satAmount) {
    return res.send({error: true, message: "error processing To Amount"})
  }

  let milliSatAmount = satAmount * 100000000 * 1000

  // round to the nearest full mill-satoshi
  milliSatAmount = Math.round(milliSatAmount / 1000) * 1000

  // the minimum is 1 satoshi, if less than that, round up to 1
  if(milliSatAmount < 1000) {
    return res.send({error: true, message: "error calculating refund amount"})
  }

  await updateOrderPaymentStatus(db, timestamp, "in-flight")
  
  const invoice = await payLnurl(orderData.Username, milliSatAmount)

  if(invoice) {
    await updateOrderPaymentStatus(db, timestamp, "complete")
    await updateOrderSettlementData(db, timestamp, {
      refund: true, 
      refunded_at: new Date().toISOString(), 
      ...invoice,
    })
    return res.send({success: true})
  }

  await updateOrderPaymentStatus(db, timestamp, null)
  return res.send({error: true, message: "an unexpected error has occurred"})
})

app.get('/payInvoice', async (req, res) => {
  const apiKey = req.query.apiKey
  const timestamp = req.query.timestamp
  const force = (req.query.force && req.query.force == 'true' ? true : false)

  if(!apiKey) {
    return res.send({error: true, message: "apiKey is required"})
  }

  if(apiKey !== admin_api_key) {
    return res.send({error: true, message: "apiKey is incorrect"})
  }

  if(!timestamp) {
    return res.send({error: true, message: "timestamp is required"})
  }

  const order = await getOrder(db, timestamp)

  if(!order) {
    return res.send({error: true, message: "order not found"})
  }

  if(order.status !== 'complete') {
    return res.send({error: true, message: "order has not been processed internally yet"})
  }

  if(order.paymentStatus === 'in-flight') {
    return res.send({error: true, message: "order payment status is currently in-flight"})
  }

  if(order.paymentStatus === 'complete') {
    return res.send({error: true, message: "order payment status is already complete, can't pay a lightning invoice twice."})
  }

  let orderData = {}
  try {
    orderData = JSON.parse(order.data)
  } catch (e) {
    console.log('error parsing order data json', e)
    return res.send({error: true, message: "error parsing order data json"})
  }

  if(orderData.Type !== "Buy") {
    return res.send({error: true, message: "can only send sats for 'Buy' orders"})
  }

  const currency = orderData["From Currency"]
  const fiatAmount = parseFloat(orderData["From Amount"].replace(/,/g, ""))
  const destination = orderData["Payment Destination"]
  const paymentIdentifier = orderData["Payment Identifier"].trim()
  const satAmount = orderData["To Amount"].replace("=(", "").replace(" / 100000000)", "")

  if(currency !== "USD" && currency !== "CRC") {
    return res.send({error: true, message: "order currency is invalid"})
  }

  const txnRate = getTxnRate(currency, 'BUY')

  if(!destination) {
    return res.send({error: true, message: "order destination is invalid"})
  }

  if(!paymentIdentifier) {
    return res.send({error: true, message: "payment identifier is invalid"})
  }

  if(!force) {
    if((satAmount / 100000000) * txnRate > fiatAmount * 1.05) {
      return res.send({error: true, message: "Fiat amount is more than 5% over current market value. Please review manually."})
    }

    if((satAmount / 100000000) * txnRate < fiatAmount * 0.95) {
      return res.send({error: true, message: "Fiat amount is more than 5% under current market value. Please review manually."})
    }

    const decodedInvoice = bolt11.decode(destination)

    if(!decodedInvoice) {
      return res.send({error: true, message: "invalid bolt11 invoice"})
    }

    if(decodedInvoice.satoshis > satAmount * 1.05) {
      return res.send({error: true, message: "invoice sat amount is more than 5% over order sat amount. Please review manually."})
    }

    if(decodedInvoice.satoshis < satAmount * 0.95) {
      return res.send({error: true, message: "invoice sat amount is more than 5% under order sat amount. Please review manually."})
    }
  }

  await updateOrderPaymentStatus(db, timestamp, 'in-flight')

  if(!force) {
    const fiatPaymentMade = await ridivi.checkHistoryForPayment({
      currency,
      paymentIdentifier,
      amount: fiatAmount,
    })

    if(!fiatPaymentMade) {
      await updateOrderPaymentStatus(db, timestamp, null)
      return res.send({error: true, message: "couldnt locate fiat payment, if you are sure then click to force-pay."})
    } else if(fiatPaymentMade && fiatPaymentMade !== true) {
      if(fiatPaymentMade.NumReferenciaSP && fiatPaymentMade.NumReferenciaSP.length > 0 && paymentIdentifier !== fiatPaymentMade.NumReferenciaSP) {
        await addPaymentIdentifier(db, fiatPaymentMade.NumReferenciaSP)

        const otherOrderExistsBySP = await getOrderByPaymentIdentifier(db, fiatPaymentMade.NumReferenciaSP, timestamp)

        if(otherOrderExistsBySP) {
          await updateOrderPaymentStatus(db, timestamp, null)
          return res.send({error: true, message: `fiat payment already used on another order ${otherOrderExistsBySP.timestamp}`})
        }
      }

      if(fiatPaymentMade.DesMovimiento && fiatPaymentMade.DesMovimiento.length > 0 && paymentIdentifier !== fiatPaymentMade.DesMovimiento) {
        const formattedDesMovimiento = fiatPaymentMade.DesMovimiento.replaceAll(/[^0-9a-z]/gi, '')
        await addPaymentIdentifier(db, fiatPaymentMade.DesMovimiento)
        await addPaymentIdentifier(db, fiatPaymentMade.DesMovimiento.split(' ')[0])

        if(formattedDesMovimiento && formattedDesMovimiento.length > 0) {
          await addPaymentIdentifier(db, formattedDesMovimiento)

          const otherOrderExistsByDes = await getOrderByPaymentIdentifier(db, formattedDesMovimiento, timestamp)

          if(otherOrderExistsByDes) {
            await updateOrderPaymentStatus(db, timestamp, null)
            return res.send({error: true, message: `fiat payment already used on another order ${otherOrderExistsByDes.timestamp}`})
          }
        }
      }
    }
  }

  const payment = await payInvoice(destination)

  if(payment) {
    await updateOrderPaymentStatus(db, timestamp, 'complete')
    await updateOrderSettlementData(db, timestamp, payment)
    return res.send({error: false, data: payment})
  }

  await updateOrderPaymentStatus(db, timestamp, null)
  return res.send({error: true, message: "Error sending payment"})
})

app.get('/payFiat', async (req, res) => {
  const apiKey = req.query.apiKey
  const timestamp = req.query.timestamp

  if(!apiKey) {
    return res.send({error: true, message: "apiKey is required"})
  }

  if(apiKey !== admin_api_key) {
    return res.send({error: true, message: "apiKey is incorrect"})
  }

  if(!timestamp) {
    return res.send({error: true, message: "timestamp is required"})
  }

  const order = await getOrder(db, timestamp)

  if(!order) {
    return res.send({error: true, message: "order not found"})
  }

  if(order.status !== 'complete') {
    return res.send({error: true, message: "order has not been processed internally yet"})
  }

  if(order.paymentStatus === 'in-flight') {
    return res.send({error: true, message: "order payment status is currently in-flight"})
  }

  if(order.paymentStatus === 'complete') {
    return res.send({error: true, message: "order payment status is already complete, can't send fiat twice."})
  }

  let orderData = {}
  try {
    orderData = JSON.parse(order.data)
  } catch (e) {
    console.log('error parsing order data json', e)
    return res.send({error: true, message: "error parsing order data json"})
  }

  if(orderData.Type !== "Sell") {
    return res.send({error: true, message: "can only send fiat for 'Sell' orders"})
  }

  const currency = orderData["To Currency"]
  const amount = parseFloat(orderData["To Amount"].replace(/,/g, ""))
  const destination = orderData["Payment Destination"]
  const satAmount = orderData["From Amount"].replace("=(", "").replace(" / 100000000)", "")
  const paymentDesc = orderData["Payment Description"] || null

  if(currency !== "USD" && currency !== "CRC") {
    return res.send({error: true, message: "order currency is invalid"})
  }

  if(!amount) {
    return res.send({error: true, message: "order amount is invalid"})
  }

  if(Number(amount).toLocaleString() !== orderData["To Amount"]) {
    return res.send({error: true, message: "error parsing fiat amount from order data. please review manually."})
  }

  const txnRate = getTxnRate(currency, 'SELL')

  if((satAmount / 100000000) * txnRate > amount * 1.05) {
    return res.send({error: true, type: "Fiat amount is more than 5% over current market value. Please review manually."})
  }

  if((satAmount / 100000000) * txnRate < amount * 0.95) {
    return res.send({error: true, type: "Fiat amount is more than 5% under current market value. Please review manually."})
  }

  if(!destination) {
    return res.send({error: true, message: "order destination is invalid"})
  }

  const isValidIban = ibantools.isValidIBAN(ibantools.electronicFormatIBAN(destination))
  const isValidSinpe = destination.replace(/[^0-9]/gi, '').trim().length === 8

  if(!isValidIban && !isValidSinpe) {
    return res.send({error: true, message: "Payment destination is not valid IBAN nor SINPE number"})
  }

  if(isValidSinpe && currency !== "CRC") {
    return res.send({error: true, message: "SINPE Movil must be CRC currency"})
  }

  await updateOrderPaymentStatus(db, timestamp, 'in-flight')

  const ourAccount = await ridivi.getAccount({currency})

  if(!ourAccount) {
    await updateOrderPaymentStatus(db, timestamp, null)
    return res.send({error: true, message: "error with getAccount"})
  }

  if(ourAccount.data.error) {
    await updateOrderPaymentStatus(db, timestamp, null)
    return res.send({error: true, message: ourAccount.data.message})
  }

  if(ourAccount.data.account.Currency !== currency) {
    await updateOrderPaymentStatus(db, timestamp, null)
    return res.send({error: true, message: "Our account currency does not match order currency"})
  }

  if(ourAccount.data.account.Blocked || ourAccount.data.account.MasterBlocked) {
    await updateOrderPaymentStatus(db, timestamp, null)
    return res.send({error: true, message: "Our account has been blocked"})
  }

  if(!ourAccount.data.account.Active) {
    await updateOrderPaymentStatus(db, timestamp, null)
    return res.send({error: true, message: "Our account is not active"})
  }

  if(parseFloat(ourAccount.data.account.Balance) < amount) {
    await updateOrderPaymentStatus(db, timestamp, null)
    return res.send({error: true, message: "Our account balance is less than the order amount to send"})
  }

  if(isValidIban) {
    const theirAccount = await ridivi.getIbanData({iban: ibantools.electronicFormatIBAN(destination)})

    if(!theirAccount) {
      await updateOrderPaymentStatus(db, timestamp, null)
      return res.send({error: true, message: "error with getIbanData"})
    }

    if(theirAccount.data.error) {
      await updateOrderPaymentStatus(db, timestamp, null)
      return res.send({error: true, message: theirAccount.data.message})
    }

    if(theirAccount.data.account.CodigoMoneda !== currency) {
      await updateOrderPaymentStatus(db, timestamp, null)
      return res.send({error: true, message: "Their account currency does not match order currency"})
    }

    const loadTransfer = await ridivi.loadTransfer({
      currency,
      toId: theirAccount.data.account.idNumber,
      toIban: ibantools.electronicFormatIBAN(destination),
      toName: theirAccount.data.account.NomPropietario,
      amount: amount,
      description: (paymentDesc || `orden ${order.id}`).padEnd(16, '_'),
      reference: timestamp,
    })

    if(!loadTransfer) {
      await updateOrderPaymentStatus(db, timestamp, null)
      return res.send({error: true, message: "error with loadTransfer"})
    }

    if(loadTransfer.data.error) {
      await updateOrderPaymentStatus(db, timestamp, null)
      return res.send({error: true, message: loadTransfer.data.message})
    }

    if(!loadTransfer.data.loadKey) {
      await updateOrderPaymentStatus(db, timestamp, null)
      return res.send({error: true, message: "loadTransfer failed to generate loadKey"})
    }

    const sendLoadedTransfer = await ridivi.sendLoadedTransfer({
      loadKey: loadTransfer.data.loadKey,
    })

    if(!sendLoadedTransfer) {
      await updateOrderPaymentStatus(db, timestamp, null)
      return res.send({error: true, message: "error with sendLoadedTransfer"})
    }

    if(sendLoadedTransfer.data.error) {
      await updateOrderPaymentStatus(db, timestamp, null)
      return res.send({error: true, message: sendLoadedTransfer.data.message || sendLoadedTransfer.data.error})
    }

    await updateOrderPaymentStatus(db, timestamp, 'complete')
    await updateOrderSettlementData(db, timestamp, sendLoadedTransfer.data)

    const phoneNumberRecord = await getPhoneNumberById(db, orderData['User'])

    if(phoneNumberRecord) {
      twilioEventHandler.emit(
        'message',
        {
          type: "sendLoadedTransfer",
          data: sendLoadedTransfer,
          name: theirAccount.data.account.NomPropietario,
          phoneNumber: phoneNumberRecord.phoneNumber,
          amount,
          currency,
        }
      )
    }

    return res.send({error: false, data: sendLoadedTransfer.data})

  } else if(isValidSinpe) {
    const phoneNumberCheck = await checkPhoneNumberForSinpe(destination.replace(/[^0-9]/gi, '').trim())

    if(phoneNumberCheck.error) {
      await updateOrderPaymentStatus(db, timestamp, null)
      return res.send({error: true, message: phoneNumberCheck.message})
    }

    const loadTransferCh4 = await ridivi.loadTransferCh4({
      phoneNumber: destination.replace(/[^0-9]/gi, '').trim(),
      description: paymentDesc || `orden ${order.id}`,
      amount,
    })

    if(!loadTransferCh4) {
      await updateOrderPaymentStatus(db, timestamp, null)
      return res.send({error: true, message: "error with loadTransferCh4"})
    }

    if(loadTransferCh4.data.error) {
      await updateOrderPaymentStatus(db, timestamp, null)
      return res.send({error: true, message: loadTransferCh4.data.message})
    }

    if(!loadTransferCh4.data.loadKey) {
      await updateOrderPaymentStatus(db, timestamp, null)
      return res.send({error: true, message: "loadTransferCh4 failed to generate loadKey"})
    }

    const sendLoadTransferCh4 = await ridivi.sendLoadTransferCh4({
      loadKey: loadTransferCh4.data.loadKey,
    })

    if(!sendLoadTransferCh4) {
      await updateOrderPaymentStatus(db, timestamp, null)
      return res.send({error: true, message: "error with sendLoadTransferCh4"})
    }

    if(sendLoadTransferCh4.data.error) {
      await updateOrderPaymentStatus(db, timestamp, null)
      return res.send({error: true, message: sendLoadTransferCh4.data.message})
    }

    if(sendLoadTransferCh4.data.result.Error) {
      await updateOrderPaymentStatus(db, timestamp, null)
      return res.send({error: true, message: sendLoadTransferCh4.data.result.CodEstado})
    }

    await updateOrderPaymentStatus(db, timestamp, 'complete')
    await updateOrderSettlementData(db, timestamp, sendLoadTransferCh4.data)

    const phoneNumberRecord = await getPhoneNumberById(db, orderData['User'])

    if(phoneNumberRecord) {
      twilioEventHandler.emit(
        'message',
        {
          type: "sendLoadTransferCh4",
          data: sendLoadTransferCh4,
          name: sendLoadTransferCh4.data.result.NombreClienteDestino,
          phoneNumber: phoneNumberRecord.phoneNumber,
          amount,
          currency,
        }
      )
    }

    return res.send({error: false, data: sendLoadTransferCh4.data})
  }

  await updateOrderPaymentStatus(db, timestamp, null)
  return res.send({error: true, message: "Payment destination is not valid IBAN nor SINPE number"})
})

app.get('/getAccounts', async (req, res) => {
  const apiKey = req.query.apiKey

  if(!apiKey) {
    return res.send({error: true, message: "apiKey is required"})
  }

  if(apiKey !== admin_api_key) {
    return res.send({error: true, message: "apiKey is incorrect"})
  }

  const crcAccount = await ridivi.getAccount({currency: "CRC"})
  const usdAccount = await ridivi.getAccount({currency: "USD"})

  return res.send({
    error: false,
    data: {
      CRC: {
        iban: ridivi_crc_account,
        data: crcAccount.data,
      },
      USD: {
        iban: ridivi_usd_account,
        data: usdAccount.data,
      }
    }
  })
})

app.get('/getHistory', async (req, res) => {
  const apiKey = req.query.apiKey
  const from = req.query.from
  const to = req.query.to
  const page = req.query.page
  const iban = req.query.iban

  if(!apiKey) {
    return res.send({error: true, message: "apiKey is required"})
  }

  if(apiKey !== admin_api_key) {
    return res.send({error: true, message: "apiKey is incorrect"})
  }

  if(!from) {
    return res.send({error: true, message: "from is required"})
  }

  if(!to) {
    return res.send({error: true, message: "to is required"})
  }

  if(!page) {
    return res.send({error: true, message: "page is required"})
  }

  if(!iban) {
    return res.send({error: true, message: "iban is required"})
  }

  const data = await ridivi.getHistory({
    from,
    to,
    page,
    iban,
  })

  if(!data) {
    res.send({error: true, message: "getHistory error"})
  }

  if(data.error) {
    res.send({error: true, message: data.message})
  }

  return res.send(data.data)
})

app.get('/getOrders', async (req, res) => {
  const apiKey = req.query.apiKey
  const from = req.query.from
  const to = req.query.to

  if(!apiKey) {
    return res.send({error: true, message: "apiKey is required"})
  }

  if(apiKey !== admin_api_key) {
    return res.send({error: true, message: "apiKey is incorrect"})
  }

  if(!from) {
    return res.send({error: true, message: "from is required"})
  }

  if(!to) {
    return res.send({error: true, message: "to is required"})
  }

  const data = await getOrders(db, from, to)

  if(!data) {
    res.send({error: true, message: "orderHistory error"})
  }

  return res.send({success: true, data: data.sort((x, y) => x.timestamp - y.timestamp).reverse()})
})

app.get('/alert', async (req, res) => {
  const alert = await getAlert(db)

  return res.send({error: (alert ? false : true), data: alert})
})

app.post('/alert', async (req, res) => {
  const active = (req.body.active ? true : false)
  let message = req.body.message
  const apiKey = req.body.key
  const types = req.body.types

  if(!apiKey) {
    return res.send({error: true, message: "apiKey is required"})
  }

  if(apiKey !== admin_api_key) {
    return res.send({error: true, message: "apiKey is incorrect"})
  }

  if(active && !message) {
    return res.send({error: true, message: "Must include a message if setting active"})
  }

  if(!active && message) {
    let message = null
  }

  const alert = await updateAlert(db, active, message)

  if(types) {
    await updateAlertTypes(db, types)
  }

  return res.send({error: alert ? false : true})
})

app.get('/priceHistory', async (req, res) => {
  const apiKey = req.query.apiKey
  const fiatCurrency = req.query.fiatCurrency
  
  if(!apiKey) {
    return res.send({error: true, type: "apiKeyRequired"})
  }

  if(apiKey !== api_key) {
    return res.send({error: true, type: "apiKeyIncorrect"})
  }

  if(!fiatCurrency) {
    return res.send({error: true, type: "fiatCurrencyRequired"})
  }

  const data = await getBullHistory('BTC', fiatCurrency)
  const bitcoinJungleIndex = await getBitcoinJunglePrice("ONE_DAY")

  if(!data || !data.result) {
    return res.send({error: true, message: "Error loading map data"})
  }

  const output = data.result.map((el) => {
    const d = new Date(el.createdAt)

    const closestTimestamp = closestDate(Math.round(d.getTime() / 1000), bitcoinJungleIndex.map(indexPrice => indexPrice.timestamp))
    const closestIndexPrice = bitcoinJungleIndex.find(indexPrice => indexPrice.timestamp === closestTimestamp)
    let indexPrice = Math.round(((closestIndexPrice.price.base / 10 ** closestIndexPrice.price.offset) / 100))

    if(fiatCurrency !== 'CRC') {
      indexPrice = Math.round(indexPrice / USDCRC.indexPrice)
    }

    return {
      date: d.toISOString(),
      buy: el.toFromPrice,
      sell: el.fromToPrice,
      index: indexPrice,
    }
  })

  res.send({success: true, data: output})
})

app.get('/stats', async (req, res) => {
  const apiKey = req.query.apiKey
  const from = req.query.from
  const to = req.query.to

  if(!apiKey) {
    return res.send({error: true, message: "apiKey is required"})
  }

  if(apiKey !== admin_api_key) {
    return res.send({error: true, message: "apiKey is incorrect"})
  }

  if(!from) {
    return res.send({error: true, message: "from is required"})
  }

  if(!to) {
    return res.send({error: true, message: "to is required"})
  }

  const orders = await getOrders(db, from, to)

  if(!orders) {
    return res.send({error: true, message: "no orders found"})
  }

  const data = orders.map((el) => {
    let orD = {}
    let settlementData = {}

    try {
      orD = JSON.parse(el.data)
    } catch (e) {
      console.log('json error orderData', e)
    }

    try {
      settlementData = JSON.parse(el.settlementData)
    } catch (e) {
      console.log('json error settlementData', e)
    }

    return {
      ...orD,
      settlementData,
    }
  })

  const output = {
    total_count: 0,

    total_sells_count: 0,
    total_sells_btc: 0,
    total_sells_usd: 0,
    total_sells_count_usd: 0,
    total_sells_crc: 0,
    total_sells_count_crc: 0,
    total_sells_dollarized: 0,

    total_buys_count: 0,
    total_buys_usd: 0,
    total_buys_btc: 0,
    total_buys_count_usd: 0,
    total_buys_crc: 0,
    total_buys_count_crc: 0,
    total_buys_dollarized: 0,

    net_btc: 0,
    net_crc: 0,
    net_usd: 0,

    btc_reserve: 0,
    cad_reserve: 0,
    btc_average_cost: 0,
  }

  for (var i = data.length - 1; i >= 0; i--) {
    const el = data[i]

    if(el.settlementData && el.settlementData.refund) {
      continue
    }
  
    output.total_count += 1

    if(el['Type'] === 'Buy') {

      const satAmount = parseFloat(eval(el['To Amount'].replace('=', '')))
      const fiatAmount = parseFloat(el['From Amount'].replace(',', ''))
      let dollarizedAmount, canadianizedAmount

      if(el['From Currency'] === 'USD') {
        dollarizedAmount = fiatAmount
      } else if(el['From Currency'] === 'CRC') {
        dollarizedAmount = parseFloat(fiatAmount / (el['USD/CRC'] || USDCRC.indexPrice))
      }

      canadianizedAmount = (dollarizedAmount * (el['USD/CAD'] || USDCAD))

      output.total_buys_count += 1
      output.total_buys_btc += satAmount

      if(el['From Currency'] === 'USD') {
        output.total_buys_usd += fiatAmount
        output.total_buys_count_usd += 1
      } else if(el['From Currency'] === 'CRC') {
        output.total_buys_crc += fiatAmount
        output.total_buys_count_crc += 1
      }

      output.total_buys_dollarized += dollarizedAmount

      output.btc_reserve -= satAmount
      output.cad_reserve += canadianizedAmount
      output.btc_average_cost = parseFloat(Math.abs(output.cad_reserve) / Math.abs(output.btc_reserve))

    } else if(el['Type'] === 'Sell') {

      const satAmount = parseFloat(eval(el['From Amount'].replace('=', '')))
      const fiatAmount = parseFloat(el['To Amount'].replace(',', ''))
      let dollarizedAmount, canadianizedAmount

      if(el['To Currency'] === 'USD') {
        dollarizedAmount = fiatAmount
      } else if(el['To Currency'] === 'CRC') {
        dollarizedAmount = parseFloat(fiatAmount / (el['USD/CRC'] || USDCRC.indexPrice))
      }

      canadianizedAmount = (dollarizedAmount * (el['USD/CAD'] || USDCAD))

      output.total_sells_count += 1
      output.total_sells_btc +=  satAmount

      if(el['To Currency'] === 'USD') {
        output.total_sells_usd += fiatAmount
        output.total_sells_count_usd += 1
      } else if(el['To Currency'] === 'CRC') {
        output.total_sells_crc += fiatAmount
        output.total_sells_count_crc += 1
      }

      output.total_sells_dollarized += dollarizedAmount

      output.btc_reserve += satAmount
      output.cad_reserve -= canadianizedAmount
      output.btc_average_cost = parseFloat(Math.abs(output.cad_reserve) / Math.abs(output.btc_reserve))
    }
  }

  output.total_sells_btc = Number(output.total_sells_btc).toFixed(8)
  output.total_buys_btc = Number(output.total_buys_btc).toFixed(8)
  output.net_btc = Number(output.total_sells_btc - output.total_buys_btc).toFixed(8)

  output.total_sells_usd = Number(output.total_sells_usd).toFixed(2)
  output.total_sells_crc = Number(output.total_sells_crc).toFixed(2)
  output.total_sells_dollarized = Number(output.total_sells_dollarized).toFixed(2)

  output.total_buys_usd = Number(output.total_buys_usd).toFixed(2)
  output.total_buys_crc = Number(output.total_buys_crc).toFixed(2)
  output.total_buys_dollarized = Number(output.total_buys_dollarized).toFixed(2)

  output.net_crc = Number(output.total_buys_crc - output.total_sells_crc).toFixed(2)
  output.net_usd = Number(output.total_buys_usd - output.total_sells_usd).toFixed(2)

  output.btc_reserve = Number(output.btc_reserve).toFixed(8)
  output.cad_reserve = Number(output.cad_reserve).toFixed(2)
  output.btc_average_cost = Number(output.btc_average_cost).toFixed(2)

  return res.send(output)
})

app.get('/phoneNumbers', async (req, res) => {
  const apiKey = req.query.apiKey

  if(!apiKey) {
    return res.send({error: true, message: "apiKey is required"})
  }

  if(apiKey !== admin_api_key) {
    return res.send({error: true, message: "apiKey is incorrect"})
  }

  const data = await getPhoneNumbers(db)

  return res.send({success: true, data: data})
})

app.post('/phoneNumber', async (req, res) => {
  const apiKey = req.body.apiKey
  const id = req.body.id
  const data = req.body.data

  if(!apiKey) {
    return res.send({error: true, message: "apiKey is required"})
  }

  if(apiKey !== admin_api_key) {
    return res.send({error: true, message: "apiKey is incorrect"})
  }

  if(!id) {
    return res.send({error: true, message: "id is required"})
  }

  if(!data) {
    return res.send({error: true, message: 'data is required'})
  }

  const phoneNumber = await getPhoneNumberById(db, id)

  if(!phoneNumber) {
    return res.send({error: true, message: "phoneNumber not found"})
  }

  if(data.phoneNumber) {
    const existing = await getPhoneNumber(db, data.phoneNumber)

    if(existing && existing.id != id) {
      return res.send({error: true, message: "phoneNumber already exists"})
    }
  }

  const updated = await updatePhoneNumber(db, id, data)

  if(!updated) {
    return res.send({error: true, message: "error updating phone number"})
  }

  return res.send({success: true})
})

app.get('/checkLimit', async (req, res) => {
  const apiKey = req.query.apiKey
  const action = req.query.action
  const fiatAmount = req.query.fiatAmount
  const fiatCurrency = req.query.fiatCurrency
  const phoneNumber = (req.query.phoneNumber ? req.query.phoneNumber.replace(/[^\d]+/g, "").trim() : null)

  if(!apiKey) {
    return res.send({error: true, type: "apiKeyRequired"})
  }

  if(apiKey !== api_key) {
    return res.send({error: true, type: "apiKeyIncorrect"})
  }

  if(!action) {
    return res.send({error: true, type: "actionRequired"})
  }

  if(!fiatAmount) {
    return res.send({error: true, type: "fiatAmountRequired"})
  }

  if(!fiatCurrency) {
    return res.send({error: true, type: "fiatCurrencyRequired"})
  }

  if(!phoneNumber) {
    return res.send({error: true, message: "phoneNumberRequired"})
  }

  const isOver = await isUserOverDailyLimit({action, phoneNumber, fiatAmount, fiatCurrency})

  if(isOver) {
    return res.send({error: true, type: "isOverDailyLimit", data: isOver})
  }

  return res.send({success: true})
})

app.get('/invoice', async (req, res) => {
  const apiKey = req.query.apiKey
  const timestamp = req.query.timestamp

  if(!apiKey) {
    return res.send({error: true, type: "apiKeyRequired"})
  }

  if(apiKey !== api_key) {
    return res.send({error: true, type: "apiKeyIncorrect"})
  }

  if(!timestamp) {
    return res.send({error: true, message: "Missing timestamp"})
  }

  const invoice = await checkInvoice(timestamp)

  if(!invoice) {
    return res.send({error: true, message: "cant find invoice"})
  }

  return res.send({error: false, data: invoice})
})

app.get('/reconcileInvoices', async (req, res) => {
  const apiKey = req.query.apiKey
  const since = req.query.since

  if(!apiKey) {
    return res.send({error: true, type: "apiKeyRequired"})
  }

  if(apiKey !== admin_api_key) {
    return res.send({error: true, type: "apiKeyIncorrect"})
  }

  const output = await reconcileInvoices(since)

  res.send({success: true, count: output.length, invoices: output})
})

app.post('/deleteOrder', async (req, res) => {
  const apiKey = req.body.apiKey
  const timestamp = req.body.timestamp

  if(!apiKey) {
    return res.send({error: true, type: "apiKeyRequired"})
  }

  if(apiKey !== admin_api_key) {
    return res.send({error: true, type: "apiKeyIncorrect"})
  }

  if(!timestamp) {
    return res.send({error: true, message: "Missing timestamp"})
  }

  const order = await getOrder(db, timestamp)

  if(!order) {
    return res.send({error: true, message: "cant find order"})
  }

  const orderData = JSON.parse(order.data)

  if(orderData.Type === 'Buy' && orderData["Payment Identifier"]) {
    await deletePaymentIdentifier(db, orderData["Payment Identifier"])
  }

  await deleteOrder(db, timestamp)

  return res.send({success: true})
})

const payInvoice = async (bolt11) => {
  try {
    // const proxyPort = (process.env.NODE_ENV !== "production" ? 9150 : 9050)
    // const httpsAgent = new SocksProxyAgent(`socks://127.0.0.1:${proxyPort}`, {rejectUnauthorized: false})

    const response = await axios(sparkwallet_url, {
      method: "POST",
      auth: {
        username: sparkwallet_user,
        password: sparkwallet_password,
      },
      data: {
        method: "_pay",
        params: [
          bolt11,
          null,
        ],
      },
      // rejectUnauthorized: false,
      // httpsAgent,
    })

    if(response.data.status === "complete") {
      return response.data
    }

    return false

  } catch (e) {
    console.log('error paying invoice', e)
    return false
  }
}

const reconcileInvoices = async (date) => {
  let sinceDate
  if(date) {
    sinceDate = new Date(date)
  }

  if(!sinceDate) {
    sinceDate = new Date()
    sinceDate.setDate(sinceDate.getDate() - 1)
    sinceDate.setUTCHours(0,0,0,0)
  }

  console.log('reconciling invoices since ', sinceDate.toISOString())

  const output = []

  const invoices = await listInvoices()

  for(const invoice of invoices) {
    if(invoice.label && invoice.status === 'paid') {
      const timestamp = new Date(invoice.label)
      if(timestamp && timestamp >= sinceDate) {
        const order = await getOrder(db, timestamp.toISOString())

        if(!order) {
          output.push(invoice)
        }
      }
    }
  }

  if(output.length) {
    console.log(`${output.length} invoices require manual reconciliation since ${sinceDate.toISOString()}`)

    let message = `🚨 ${output.length} invoices require manual reconciliation 🚨\n\n`

    for(const invoice of output) {
      message += `- ${invoice.label}: ${invoice.description}\n`
    }

    let optionsObj = {}
    optionsObj.reply_markup = {
      inline_keyboard: [
        [
          {
            text: "View Invoices",
            url: `https://orders.bitcoinjungle.app/reconcileInvoices?apiKey=${admin_api_key}`
          }
        ],
      ],
    }

    const tgMsg = await bot.telegram.sendMessage(
      chat_id, 
      message,
      optionsObj
    )
  } else {
    console.log('reconciled and no issues since ', sinceDate.toISOString())
  }

  return output
}

setInterval(reconcileInvoices, 1000 * 60 * 60)

const listInvoices = async () => {
  const response = await axios(sparkwallet_url, {
    method: "POST",
    auth: {
      username: sparkwallet_user,
      password: sparkwallet_password,
    },
    data: {
      method: "_listinvoices",
      params: [

      ],
    },
    // rejectUnauthorized: false,
    // httpsAgent,
  })

  return response.data.invoices
}

const checkPhoneNumberForSinpe = async (phoneNumber) => {
  const response = await ridivi.getInfoNumCh4({ phoneNumber })

  if(!response) {
    return {
      error: true,
      message: "An unexpected error has occurred.",
    }
  }

  if(response.data.error) {
    return {
      error: true,
      message: response.data.message || "An unexpected error has occurred.",
    }
  }

  if(response.data.result.error) {
    return {
      error: true,
      message: response.data.result.message || "An unexpected error has occurred.",
    }
  }

  return { 
    error: false,
    data: response.data.result,
  }
}

const checkIbanAccount = async (iban) => {
  const response = await ridivi.getIbanData({ iban })

  if(!response) {
    return {
      error: true,
      message: "An unexpected error has occurred.",
    }
  }

  if(response.data.error) {
    return {
      error: true,
      message: response.data.message || "An unexpected error has occurred.",
    }
  }

  if(response.data.account.error) {
    return {
      error: true,
      message: response.data.account.message || "An unexpected error has occurred.",
    }
  }

  if(!response.data.account.NomPropietario) {
    return {
      error: true,
      message: "No se encuentra el propietario de esta cuenta IBAN.",
    }
  }

  return { 
    error: false,
    data: response.data.account,
  }
}

const sendOrderToTelegram = async (rowData, formulaFreeAmount, timestamp, error) => {
  try {
    let message = `🚨 Order Requires Manual Review 🚨\n\n`
    message += `❌ Error Message: ${error}\n\n`

    Object.keys(rowData).forEach(key => {
      let val = rowData[key]

      if(val && val.toString().length) {
        if(val[0] === '=') {
          val = formulaFreeAmount
        }

        message += `${key}: ${val}\n`
      }
    })

    const optionsObj = {}

    if(rowData.Type === "Buy") {
      optionsObj.reply_markup = {
        inline_keyboard: [
          [
            {
              text: "Force Pay Lightning Invoice",
              url: `https://orders.bitcoinjungle.app/payInvoice?apiKey=${admin_api_key}&timestamp=${timestamp}&force=true`
            }
          ],
        ],
      }
    } else if(rowData.Type === "Sell") {
      optionsObj.reply_markup = {
        inline_keyboard: [
          [
            {
              text: "Pay Out Fiat",
              url: `https://orders.bitcoinjungle.app/payFiat?apiKey=${admin_api_key}&timestamp=${timestamp}`
            }
          ],
        ],
      }
    }

    const resp = await bot.telegram.sendMessage(
      chat_id, 
      message,
      optionsObj
    )

    return resp
  } catch(e) {
    console.log('telegram error', e)

    return false
  }
}

const addRowToSheet = async (rowData, sheetIndex) => {
  try {
    const sheet = doc.sheetsByIndex[sheetIndex]

    await new Promise(resolve => setTimeout(resolve, (Math.floor(Math.random() * 6) + 1) * 1000))

    const newRow = await sheet.addRow(rowData, {insert: true})

    console.log('row added to sheet ' + sheetIndex)

    return true
  } catch(e) {
    console.log('gsheet error adding to sheet ' + sheetIndex, e)

    return false
  }
}

const sendUserAddMessage = async (bitcoinJungleUsername, phoneNumber, phoneName) => {
  try {
    let message = `New User Requesting Access\n`
    message += `Username: ${bitcoinJungleUsername}\n`
    message += `Phone Number: ${phoneNumber}\n`

    if(phoneName && phoneName.length > 0) {
      message += `✅ Name registered on SINPE Movil: ${phoneName}`
    } else {
      message += `❌ Phone number not registered on SINPE Movil`
    }

    const optionsObj = {
      reply_markup: {
        inline_keyboard: [
          [
            {
              text: "Approve User",
              url: `https://orders.bitcoinjungle.app/approveUser?bitcoinJungleUsername=${bitcoinJungleUsername}&apiKey=${admin_api_key}`
            },
          ],
        ],
      }
    }

    const resp = await bot.telegram.sendMessage(
      chat_id, 
      message, 
      optionsObj
    )

    return resp
  } catch(e) {
    console.log('telegram error', e)

    return false
  }
}

const checkInvoice = async (label) => {
  const invoiceData = {
    jsonrpc: "2.0",
    id: Math.floor(Math.random() * 1001).toString(),
    method: "getInvoice",
    params: {
      label: label,
    }
  }

  try {
    const response = await axios(invoice_endpoint_url, {
      method: "POST",
      auth: {
        username: invoice_endpoint_user,
        password: invoice_endpoint_password,
      },
      data: invoiceData,
    })

    if(response.data.result.status === 'paid') {
      return response.data.result
    }

    return false
    
  } catch(e) {
    console.log('error checking invoice', e)
    return false
  }
}

const fetchLnUrl = async (bitcoinJungleUsername, milliSatAmount, callback) => {
  try {
    const response = await axios(
      (!callback ? lnurl_base_url + ".well-known/lnurlp/" + bitcoinJungleUsername : callback) + (milliSatAmount ? "?amount=" + milliSatAmount : "")
    )
    
    return response.data
  } catch (err) {
    console.log('fetchLnUrl fail', err)
    return false
  }
}

const payLnurl = async (username, amount) => {
  // hit the LNURL endpoint for Bitcoin Jungle
  const lnUrl = await fetchLnUrl(username)

  console.log(lnUrl)

  if(!amount || amount == 0) {
    return true
  }

  if(!lnUrl) {
    console.log('no lnurl')
    return false
  }

  if(!lnUrl.callback) {
    console.log('no lnurl callback')
    return false
  }

  // use the Bitcoin Jungle LNURL endpoint to generate a bolt11 invoice for the milli-satoshi amount calculated
  const lnUrlWithAmount = await fetchLnUrl(username, amount, lnUrl.callback)

  if(!lnUrlWithAmount) {
    console.log('no lnUrlWithAmount')
    return false
  }

  if(lnUrlWithAmount.status == "ERROR") {
    return false
  }

  if(!lnUrlWithAmount.pr) {
    return false
  }
  
  const lnInvoice = await payInvoice(lnUrlWithAmount.pr)

  if(lnInvoice) {
    return lnInvoice
  }

  return false
}

const getBitcoinJunglePrice = async (range) => {
  try {
    const response = await axios({
      method: "POST",
      url: "https://api.mainnet.bitcoinjungle.app/graphql",
      headers: {
        "Content-Type": "application/json"
      },
      data: {
        query: "query BtcPriceList($range: PriceGraphRange!) {\n  btcPriceList(range: $range) {\n    price {\n      base\n      currencyUnit\n      formattedAmount\n      offset\n    }\n    timestamp\n  }\n}",
        variables: {
          range,
        },
        operationName: "BtcPriceList"
      }
    })

    if(!response || !response.data || !response.data.data || !response.data.data.btcPriceList || !response.data.data.btcPriceList.length) {
      return false
    }

    return response.data.data.btcPriceList
  } catch (e) {
    console.log('getBitcoinJunglePrice error', e)
    return false
  }
}

const getBullPrice = async (from, to) => {
  try {
    const response = await axios({
      method: "POST",
      url: price_data_url,
      headers: {
        "Content-Type": "application/json"
      },
      data: {
        "id": Math.floor(Math.random() * 1001).toString(),
        "jsonrpc": "2.0",
        "method": "getRate",
        "params": {
          "to": to,
          "from": from
        }
      }
    })

    return response
  } catch(e) {
    console.log('error getBullPrice', from, to)
    await new Promise(resolve => setTimeout(resolve, 5000))
    return await getBullPrice(from, to)
  }
}

const getBullHistory = async (from, to) => {
  let fromDate = new Date()
  fromDate.setDate(fromDate.getDate() - 1)

  try {
    const response = await axios({
      method: "POST",
      url: price_data_url,
      headers: {
        "Content-Type": "application/json"
      },
      data: {
        id: Math.floor(Math.random() * 1001).toString(),
        jsonrpc: "2.0",
        method: "listRates",
        params: {
          to,
          from,
          period: "hour",
          range: {
            start: fromDate.toISOString(),
            end: new Date().toISOString(),
          }
        }
      }
    })

    if(!response) {
      return false
    }

    if(!response.data) {
      return false
    }

    return response.data
  } catch(e) {
    console.log('error getBullRates', from, to)
    return false
  }
}

const getUsdCrc = async () => {
  try {
    const crcFiatResponse = await axios.get(`https://api.exchangeratesapi.io/v1/latest?access_key=${exchange_rate_api_key}&base=USD&symbols=CRC`)

    if(!crcFiatResponse || !crcFiatResponse.data || !crcFiatResponse.data.success || !crcFiatResponse.data.rates || !crcFiatResponse.data.rates || !crcFiatResponse.data.rates.CRC) {
     return {error: true, message: "Error fetching price"}
    }

    USDCRC = {indexPrice: crcFiatResponse.data.rates.CRC}

    console.log('set USDCRC to ', USDCRC)
  } catch(e) {
    console.log('error setting USDCRC', e)
    setTimeout(getUsdCrc, 5000)
  }

  return USDCRC
}

// const getUsdCrc = async () => {
//   const response = await getBullPrice("USD", "CRC")

//   USDCRC = response.data.result

//   console.log('set USDCRC to', USDCRC)

//   return USDCRC
// }

setInterval(getUsdCrc, 60 * 1000 * 240)

getUsdCrc()

const getUsdCad = async () => {
  try {
    const cadFiatResponse = await axios.get(`https://api.exchangeratesapi.io/v1/latest?access_key=${exchange_rate_api_key}&base=USD&symbols=CAD`)

    if(!cadFiatResponse || !cadFiatResponse.data || !cadFiatResponse.data.success || !cadFiatResponse.data.rates || !cadFiatResponse.data.rates || !cadFiatResponse.data.rates.CAD) {
     return {error: true, message: "Error fetching price"}
    }

    USDCAD = cadFiatResponse.data.rates.CAD

    console.log('set USDCAD to ', USDCAD)
  } catch(e) {
    console.log('error setting USDCAD', e)
    setTimeout(getUsdCad, 5000)
  }
  
  return USDCAD
}

setInterval(getUsdCad, 60 * 1000 * 240)

getUsdCad()

const getBtcCrc = async () => {
  const bbResponse = await getBullPrice("BTC", "CRC")
  
  if(bbResponse && bbResponse.data && bbResponse.data.result && bbResponse.data.result.indexPrice > 0) {
    BTCCRC = bbResponse.data.result
  } else {
    console.log("Bull Bitcoin API down, falling back to Bitcoin Jungle")
    const bjResponse = await getBitcoinJunglePrice("ONE_DAY")
  
    const priceData = bjResponse.sort((a,b) => a.timestamp - b.timestamp).reverse()[0]
    const timestamp = new Date(priceData.timestamp * 1000).toISOString()
    const bjBTCCRC = parseFloat(Number(((priceData.price.base / 10 ** priceData.price.offset) / 100)).toFixed(2))

    BTCCRC = {
      createdAt: timestamp,
      fromCode: "BTC",
      toCode: "CRC",
      fromToPrice: parseFloat(Number(bjBTCCRC * 0.992).toFixed(2)),
      toFromPrice: parseFloat(Number(bjBTCCRC * 1.012).toFixed(2)),
      indexPrice: bjBTCCRC
    }
  }

  console.log('set BTCCRC to', BTCCRC)

  return BTCCRC
}

setInterval(getBtcCrc, 60 * 1000)

getBtcCrc()

const getBtcUsd = async () => {
  const bbResponse = await getBullPrice("BTC", "USD")

  if(bbResponse && bbResponse.data && bbResponse.data.result && bbResponse.data.result.indexPrice > 0) {
    BTCUSD = bbResponse.data.result
  } else {
    console.log("Bull Bitcoin API down, falling back to Bitcoin Jungle")
    const bjResponse = await getBitcoinJunglePrice("ONE_DAY")
  
    const priceData = bjResponse.sort((a,b) => a.timestamp - b.timestamp).reverse()[0]
    const timestamp = new Date(priceData.timestamp * 1000).toISOString()
    const bjBTCUSD = parseFloat(Number(((priceData.price.base / 10 ** priceData.price.offset) / 100) / USDCRC.indexPrice).toFixed(2))

    BTCUSD = {
      createdAt: timestamp,
      fromCode: "BTC",
      toCode: "USD",
      fromToPrice: parseFloat(Number(bjBTCUSD * 0.992).toFixed(2)),
      toFromPrice: parseFloat(Number(bjBTCUSD * 1.012).toFixed(2)),
      indexPrice: bjBTCUSD
    }
  }

  console.log('set BTCUSD to', BTCUSD)

  return BTCUSD
}

setInterval(getBtcUsd, 60 * 1000)

getBtcUsd()

const getBtcCad = async () => {
  const bbResponse = await getBullPrice("BTC", "CAD")

  if(bbResponse && bbResponse.data && bbResponse.data.result && bbResponse.data.result.indexPrice > 0) {
    BTCCAD = bbResponse.data.result
  } else {
    console.log("Bull Bitcoin API down, falling back to Bitcoin Jungle")
    const bjResponse = await getBitcoinJunglePrice("ONE_DAY")
  
    const priceData = bjResponse.sort((a,b) => a.timestamp - b.timestamp).reverse()[0]
    const timestamp = new Date(priceData.timestamp * 1000).toISOString()
    const bjBTCCAD = parseFloat(Number( ( ((priceData.price.base / 10 ** priceData.price.offset) / 100) / USDCRC.indexPrice ) * USDCAD).toFixed(2))

    BTCCAD = {
      createdAt: timestamp,
      fromCode: "BTC",
      toCode: "CAD",
      fromToPrice: parseFloat(Number(bjBTCCAD * 0.992).toFixed(2)),
      toFromPrice: parseFloat(Number(bjBTCCAD * 1.012).toFixed(2)),
      indexPrice: bjBTCCAD
    }
  }

  console.log('set BTCCAD to', BTCCAD)

  return BTCCAD
}

setInterval(getBtcCad, 60 * 1000)

getBtcCad()

const getPrice = async () => {
  try {
    const response = await getBitcoinJunglePrice("ONE_DAY")

    if(!response) {
      return {error: true, message: "Error fetching price"}
    }

    const priceData = response.sort((a,b) => a.timestamp - b.timestamp).reverse()[0]
    const timestamp = new Date(priceData.timestamp * 1000).toISOString()

    const BTCCRC = Math.round(((priceData.price.base / 10 ** priceData.price.offset) / 100))

    const BTCUSD = Number(BTCCRC / USDCRC.indexPrice).toFixed(2)

    const BTCCAD = Number(BTCUSD * USDCAD).toFixed(2)

    return {BTCCRC, USDCRC: USDCRC.indexPrice, USDCAD, BTCUSD, BTCCAD, timestamp}
  } catch(e) {
    return {error: true, message: "Error fetching price"}
  }
}

const getTxnRate = (currency, action) => {
  const priceData = getTicker()
  const currencyPair = `BTC${currency}`
  const direction = (action.toUpperCase() === 'BUY' ? 'toFromPrice' : 'fromToPrice')
  const indexRate = parseFloat(priceData[currencyPair][direction])

  return indexRate
}

const getTicker = () => {
  const timestamp = new Date().toISOString()

  return {
    BTCCRC,
    USDCRC,
    USDCAD,
    BTCUSD,
    BTCCAD,
    timestamp,
  }
}

const closestDate = (toDate, dates) => dates.reduce((x, date) => {
  const distance = Math.abs(toDate - date)
  if (!x.distance || distance < x.distance) {
    return {
      distance, 
      date
    }
  }
  return x
}, {}).date

const getAlert = async (db) => {
  try {
    return await db.get(
      "SELECT * FROM alert WHERE id = 1",
    )
  } catch {
    return false
  }
}

const updateAlert = async (db, active, message) => {
  try {
    return await db.run(
      "UPDATE alert SET active = ?, message = ?, timestamp = ? WHERE id = 1",
      [
        active,
        message,
        new Date().toISOString(),
      ]
    )
  } catch {
    return false
  }
}

const updateAlertTypes = async (db, types) => {
  try {
    return await db.run(
      "UPDATE alert SET types = ? WHERE id = 1",
      [
        JSON.stringify(types),
      ]
    )
  } catch {
    return false
  }
}

const getUser = async (db, bitcoinJungleUsername) => {
  try {
    return await db.get(
      "SELECT * FROM users WHERE bitcoinJungleUsername = ?", 
      [bitcoinJungleUsername]
    )
  } catch {
    return false
  }
}

const addUser = async (db, bitcoinJungleUsername) => {
  const timestamp = Math.floor(Date.now() / 1000)
  try {
    return await db.run(
      "INSERT INTO users (bitcoinJungleUsername, approved, timestamp) VALUES (?, ?, ?)", 
      [bitcoinJungleUsername, false, timestamp]
    )
  } catch(e) {
    console.log(e)
    return false
  }
}

const approveUser = async (db, bitcoinJungleUsername) => {
  const timestamp = Math.floor(Date.now() / 1000)
  try {
    return await db.run(
      "UPDATE users SET approved = true WHERE bitcoinJungleUsername = ?", 
      [bitcoinJungleUsername]
    )
  } catch {
    return false
  }
}

const deactivateUser = async (db, bitcoinJungleUsername) => {
  try {
    return await db.run(
      "UPDATE users SET approved = false WHERE bitcoinJungleUsername = ?", 
      [bitcoinJungleUsername]
    )
  } catch {
    return false
  }
}

const addPaymentIdentifier = async (db, identifier) => {
  try {
    return await db.run(
      "INSERT INTO payment_identifiers (identifier) VALUES (?)", 
      [identifier]
    )
  } catch(e) {
    console.log(e)
    return false
  }
}

const deletePaymentIdentifier = async (db, identifier) => {
  try {
    return await db.run(
      "DELETE FROM payment_identifiers WHERE identifier = ?", 
      [identifier]
    )
  } catch(e) {
    console.log(e)
    return false
  }
}

const getPaymentIdentifier = async (db, identifier) => {
  try {
    return await db.get(
      "SELECT * FROM payment_identifiers WHERE identifier = ?", 
      [identifier]
    )
  } catch {
    return false
  }
}

const getPhoneNumbers = async (db) => {
  try {
    return await db.all(
      "SELECT * FROM phone_numbers",
    )
  } catch {
    return false
  }
}

const getPhoneNumber = async (db, phoneNumber) => {
  try {
    return await db.get(
      "SELECT * FROM phone_numbers WHERE phoneNumber = ?", 
      [phoneNumber]
    )
  } catch {
    return false
  }
}

const getPhoneNumberById = async (db, id) => {
  try {
    return await db.get(
      "SELECT * FROM phone_numbers WHERE id = ?", 
      [id]
    )
  } catch {
    return false
  }
}

const updatePhoneNumber = async (db, id, data) => {
  try {
    const col = Object.keys(data)[0]
    return await db.run(
      `UPDATE phone_numbers SET ${col} = ? WHERE id = ?`, 
      [
        data[col],
        id,
      ]
    )
  } catch {
    return false
  }
}

const addPhoneNumber = async (db, phoneNumber) => {
  try {
    return await db.run(
      "INSERT INTO phone_numbers (phoneNumber, allow_instant, daily_buy_limit, daily_sell_limit, per_txn_limit) VALUES (?, ?, ?, ?, ?)", 
      [
        phoneNumber,
        true,
        parseFloat(default_daily_buy_limit),
        parseFloat(default_daily_sell_limit),
        parseFloat(default_per_txn_limit),
      ]
    )
  } catch {
    return false
  }
}

const addOrder = async (db, timestamp) => {
  try {
    return await db.run(
      "INSERT INTO orders (timestamp, status, data) VALUES (?, ?, ?)",
      [
        timestamp,
        "in-flight",
        JSON.stringify({})
      ]
    )
  } catch(e) {
    console.log('addOrder error', e)
    return false
  }
}

const isUserOverDailyLimit = async ({action, phoneNumber, fiatAmount, fiatCurrency}) => {
  let phoneUser = await getPhoneNumber(db, phoneNumber)
  let dailySellLimit = 0
  let dailyBuyLimit = 0
  let perTxnLimit = 0

  if(!phoneUser) {
    console.log('phoneUser not found')
    phoneUser = {
      id: "new",
    }
    dailySellLimit = default_daily_sell_limit
    dailyBuyLimit = default_daily_buy_limit
    perTxnLimit = default_per_txn_limit
  } else {
    dailySellLimit = phoneUser.daily_sell_limit
    dailyBuyLimit = phoneUser.daily_buy_limit
    perTxnLimit = phoneUser.per_txn_limit
  }

  const todayMidnight = new Date()
  todayMidnight.setUTCHours(0, 0, 0, 0)

  const orders = await getUserOrders(db, action, phoneUser.id, todayMidnight.toISOString())

  console.log(`phoneUser id ${phoneUser.id} has ${(orders ? orders.length : "0")} ${action} orders since ${todayMidnight.toISOString()}`)

  if(fiatCurrency === 'CRC') {
    fiatAmount = fiatAmount / USDCRC.indexPrice
  }

  fiatAmount = fiatAmount * USDCAD

  let total = fiatAmount

  if(fiatAmount > perTxnLimit) {
    console.log(`phoneUser id ${phoneUser.id} is over per txn limit of ${perTxnLimit} requesting ${fiatAmount}`)
    return {
      total,
      dailyBuyLimit,
      dailySellLimit,
      perTxnLimit,
      type: "perTxnLimit",
    }
  }

  for (var i = orders.length - 1; i >= 0; i--) {
    const order = orders[i]
    const orderData = JSON.parse(order.data)
    const settlementData = (order.settlementData ? JSON.parse(order.settlementData) : {})

    if(settlementData && settlementData.refund) {
      continue
    }

    let orderFiatAmount = 0
    let orderFiatCurrency = ''

    if(orderData.Type === 'Buy') {
      orderFiatAmount = orderData['From Amount'].replace(',', '')
      orderFiatCurrency = orderData['From Currency']
    } else {
      orderFiatAmount = orderData['To Amount'].replace(',', '')
      orderFiatCurrency = orderData['To Currency']
    }

    if(orderFiatCurrency === 'CRC') {
      orderFiatAmount = orderFiatAmount / orderData['USD/CRC']
    }

    orderFiatAmount = orderFiatAmount * orderData['USD/CAD']

    total += orderFiatAmount
  }

  console.log(`phoneUser id ${phoneUser.id} daily total of ${action} is ${total}. Limits are buy: ${dailyBuyLimit}, sell: ${dailySellLimit}`)

  if(
    (action.toUpperCase() === 'BUY' && total > dailyBuyLimit) ||
    (action.toUpperCase() !== 'BUY' && total > dailySellLimit)
  ) {
    return {
      total,
      dailyBuyLimit,
      dailySellLimit,
      perTxnLimit,
      type: "dailyLimit",
    }
  }

  return false
}

const getUserOrders = async (db, type, userId, since) => {
  try {
    return await db.all(
      `
        SELECT * 
        FROM orders 
        WHERE json_extract(data, '$.User') = ? 
        AND json_extract(data, '$.Type') = ? 
        AND timestamp >= ?
      `, 
      [
        userId,
        type[0].toUpperCase() + type.slice(1).toLowerCase(),
        since,
      ]
    )
  }catch(e) {
    console.log('getUserOrders error', e)
    return false
  }
}

const getOrders = async (db, from, to) => {
  try {
    return await db.all(
      `
        SELECT o.*, p.phoneNumber as "Phone Number"
        FROM orders o 
        JOIN phone_numbers p ON p.id = json_extract(o.data, '$.User')
        WHERE o.timestamp >= ? 
        AND o.timestamp <= ? 
        AND o.status = 'complete'
      `,
      [
        from,
        to,
      ]
    )
  } catch(e) {
    console.log('getOrders error', e)
    return false
  }
}

const getOrder = async (db, timestamp) => {
  try {
    return await db.get(
      "SELECT * FROM orders WHERE timestamp = ?", 
      [timestamp]
    )
  }catch(e) {
    console.log('getOrder error', e)
    return false
  }
}

const getOrderByPaymentIdentifier = async (db, paymentIdentifier, notTimestamp) => {
  try {
    return await db.get(
      "SELECT * FROM orders WHERE json_extract(data, '$.Payment Identifier') = ? AND timestamp != ?", 
      [
        paymentIdentifier,
        notTimestamp,
      ]
    )
  }catch(e) {
    console.log('getOrderByPaymentIdentifier error', e)
    return false
  }
}

const updateOrderStatus = async (db, timestamp, status) => {
  try {
    return await db.run(
      "UPDATE orders SET status = ? WHERE timestamp = ?",
      [
        status,
        timestamp,
      ]
    )
  } catch(e) {
    console.log('updateOrderStatus error', e)
    return false
  }
}

const updateOrderPaymentStatus = async (db, timestamp, paymentStatus) => {
  try {
    return await db.run(
      "UPDATE orders SET paymentStatus = ? WHERE timestamp = ?",
      [
        paymentStatus,
        timestamp,
      ]
    )
  } catch(e) {
    console.log('updateOrderPaymentStatus error', e)
    return false
  }
}

const updateOrderSettlementData = async (db, timestamp, data) => {
  try {
    return await db.run(
      "UPDATE orders SET settlementData = ? WHERE timestamp = ?",
      [
        JSON.stringify(data),
        timestamp,
      ]
    )
  } catch(e) {
    console.log('updateOrderSettlementData error', e)
    return false
  }
}

const updateOrderData = async (db, timestamp, data) => {
  try {
    return await db.run(
      "UPDATE orders SET data = ? WHERE timestamp = ?",
      [
        JSON.stringify(data),
        timestamp,
      ]
    )
  } catch(e) {
    console.log('updateOrderData error', e)
    return false
  }
}

const deleteOrder = async (db, timestamp) => {
  try {
    return await db.run(
      "DELETE FROM orders WHERE timestamp = ?",
      [
        timestamp,
      ]
    )
  } catch(e) {
    console.log('deleteOrder error', e)
    return false
  }
}

const getDestinationBlocklist = async (db, destination) => {
  try {
    return await db.get(
      "SELECT * FROM destination_blocklist WHERE destination = ?",
      [
        destination,
      ]
    )
  } catch(e) {
    console.log('getDestinationBlocklist error', e)
    return false
  }
}

const server = app.listen(port, () => console.log("Listening on port", port))
server.setTimeout(1000 * 60 * 9)